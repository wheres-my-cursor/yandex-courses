# 1. Введение
## Чем Python отличается от других языков?
- Простой синтаксис
- Широкая сфера применения
- Большое сообщество
- Множество библиотек

Python был создан в 1991 году Гвидо ван Россумом, программистом из Нидерландов.
Считается интерпретируемым языком, но на самом деле его код сначала компилируется в байт-код, а он в свою очередь выполняется интерпретатором.

Самый распроспранённый интерпретатор - CPython.

# 2.1. Базовые конструкции Python
## Ввод и вывод данных. Операции с числами, строками. Форматирование
### Строки
В Python строки заключаются в кавычки:
- одинарные
- двойные
- тройные двойные
Можно сочетать виды кавычек, чтобы ставлять одни внутрь других.

### Ввод данных
input() - получает данные с клавиатуры и возвращает в виде строки.
### Вывод данных
print()
    sep (separator)
    end

### Переменные
начинают существовать в программе, когда в них записываются какие-то значения. 

В Python принят стандарт оформления кода PEP 8 (Python Enhancement Proposals).
            https://peps.python.org/
Он рекомендует называть переменные
- понятными содержательными именами
- используя строчные буквы английского алфавита
- и знак подчеркивания для разделения слов
- в случае, если используются однобуквенные переменные, стоит избегать I, l, O.

Вокруг именнованных аргументов не ставятся пробелы.

### f-строки
- можно встроить переменные прямо внутрь строки
- удобно форматировать

Чтобы задать f-строку, нужно поставить букву f перед открывающей кавычкой.

Можно
- выполнять операции
```
print(f"{1+1}")
```
- вызывать функции
```
print(f"{input()}")
```
- настраивать выравнивание
```
print(f"{123:0>9}")     # по правому краю
print(f"{123:0<9}")     # по левому краю
print(f"{123:0^9}")     # по центру
```
- округление
```
print(f"2 ** 0.5:.2f}") # Округлит до двух знаком после запятой
```

### Другие способы
#### format()
```
print("Привет, {}!".format(input()))
```
#### %
```
print("Привет, %s!" % input())
```
### Управляющие символы
\n, \t, \r, \b
С помощью \ можно экранировать символы, т.е. делать их частью выводимой строки.

### Операции со строками
- Конкатенация
- Умножение на целое число
### Операции с числами
Существует два основных типа чисел
- Целые
- Вещественные (float, с плавающей точкой)
#### Преобразование типов
- int() - просто отбрасывает дробную часть у float
- float()
- str()
#### Основные арифметические операции
+, -, \*, /, **, //, %

Если выполняется операция деления или хотя бы один из операндов - вещественное число, то результат тоже будет вещественным.
##### Порядок выполнения операций (приоритет)
1. **
2. *, /, %, //
3. +, -
### Системы счисления
int() с параметрами:
    строка
    основание системы счисления
переведет в 10ю систему счисления
из десятичной в другую:
bin(), oct(), hex()

# 2.2. Условный оператор
if условие:
    # код, который выполнится, если условие истинно
elif другое_условие:
    # код, если первое условие не сработало, но это — истинно
else:
    # код, если ни одно из условий не сработало

## Математические операторы
>, >=, <, <=, ==, !=
Можно использовать двойное неравенство

## Логические операторы
and, or, not

## Сравннеие строк
Python сравнивает строки в лексикографическом порядке - по таблице кодировки символов (обычно UTF-8)

ord() - возвращает код символа из таблица кодировки
chr() - возвращает символ по коду

.lower() - переводит в нижний регистр

in - используется, чтобы проверять наличие одного слова в другом

## Match-case
```
color = input()
match color:
    case 'красный' | 'жёлтый':
        print('Стоп.')
    case 'зелёный':
        print('Можно ехать.')
    case _:
        print('Некорректное значение.')
```
- В операторе case не используется логическая операция or. Ее нельзя использовать, посколью она применяется для переменных логического типа. Вместо нее используется оператор |.
- Последний оператор case выполняется всегда и сработает в случае, если ни одно из предыдущих условий не сработало.

## Проверка условий при помощи встроенных функций
max(), min(), len()
    !!! https://docs.python.org/3/library/functions.html

## Комментарии
Начинаются с #

# 2.3. Циклы
## While
- Использование табуляции вместо пробелов не рекомендуется, т.к. может вызвать ошибки при выполнении.
- Каждый проход по телу цикла - итерация.
- Если действий выполнять не нужно, вставляется pass. В Python нельзя оставлять тело цикла пустым - это вызовет ошибку.
## Моржовый оператор (:=)
или walrus operator

Позволяет одновременно:
- присвоить значение переменной
- использовать это значение в цикле
```
while (name := input("Введите имя: ")) != "СТОП":
    print(f"Привет, {name}!")
print("Программа завершена.")
```
## For
- Используется, когда количество итераций заранее известно.
- range() - задает диапазон значений. Это не функция, строго говоря, а встроенный тип данных (Built-in Type), который создает последовательность целых чисел.

# 2.4. Вложенные циклы
Общее количество итераций равно произведению количества итераций всех циклов.

## Оператор break
Останавливает только тот цикл, в котором бы вызвал. Для того, чтобы остановить внешние циклы, нужно использовать дополнительные конструкции, например, флаги.

## Оператор continue
Используется, чтобы пропустить выполнение оставшейся части тела цикла на текущей итерации.
Действует только на тот цикл, в котором непосредственно находится.

## Оператор else в циклах
Код, записанный в блоке else, выполняется в том случае, если цикл завершился естественно:
- для while - когда нарушилось условие продолжения
- для for - когда закончились все элементы в последовательности

Если в теле цикла используется оператор break, который преждеверменно останавливает цикл, код в else не будет выполнен.

# 3.1. Строки, кортежи, списки. Упорядоченные колллекции.
Слово "коллекция" в Python используется для обозначения типов данных, которые могут хранить сразу несколько значений.
## Упорядоченные коллекции: строки, списки и кортежи.
### Индексация
Элементы автоматически получают индексы.
Индексация начинается с нуля.
Чтобы получить элемент по индексу, нужно указать индекс в квадратных скобках после переменной.
Когда нужно обратиться к символам с конца строки, можно использовать отрицательную индексацию.
### Проход по колллекциям
- по индексам
```
text = input()
for i in range(len(text)):
    print(text[i])
```
- по значениям
```
text = input()
for letter in text:
    print(letter)
```
- по индексам и значениям одновроменно (с помощью enumerate())
```
text = input()
for i, letter in enumerate(text):
    print(f"{i}. {letter}")
```
### Срезы
коллекция[начало:конец:шаг]
- конец не включается
- любой из параметров можно опустить
- работает и отрицательная индексация

### Строки ""
Неизменяемая коллекция
#### Методы
Не изменяют исходную строку, а возвращают новую
str.islower()
str.capitalize()            Первая буква заглавная, а остальные строчные
str.count(sub)
str.endswith(suffix)        True/False
str.find(sub)
str.index(sub)
str.isalnum()               True, если все символы являются буквами и цифрами и len() > 0
str.isalpha()               True, если все символы - буквы и len() > 0
str.isdigit()
str.islower()
str.isupper()
str.join(str_col)
```
a = ["1", "2", "3"]
"; ".join(a)
```
str.ljust(width, fillchar)  Возвращает строку длиной width с выравниванием по левому краю. Строка дополняется справа символами fillchar (по умолчанию - пробел).
str.lower()
str.lstrip(chars)           Удаляет в начале символы, встречающиеся в строке chars (п/у - пробел)
str.rstrip(chars)           Удаляет в конце символы, встречающиеся в строке chars (п/у - пробел)
str.split(sep)
str.startswith(prefix)
str.strip(chars)            Удаляет в начале и в конце символы, встречающиеся в строке chars (п/у - пробел)
str.title()                 Каждое слово начинается с заглавной буквы, остальные - в нижнем.
str.upper() 
str.zfill(width)            Дополняет строку слева символами 0 до длины width

### Списки []
- изменяемые коллекции (numbers[2] = 30 не вызовет ошибку)
- может содержать элементы любых типов данных
- индексация такая же, как в строках
- поддерживает срезы
#### Методы и операции
s.append(x)                 Добавляет x в конец списка s
del                         Удаляет элементы/срез
x in s
x not in s
s + t                       Конкатенация
s * n (n * s)               Возвращает список, полученный дублированием n раз списка s
len(s)
min(s)
max(s)
s.index(x)                  Возращает индекс первого x, и ошибку, если его нет в списке
s.count(x)
s.append(x)
s.clear()
s.copy()
s.extend(t) или s += t
s.insert(i,x)
s.pop(i)                    Возвращает и удаляет элемент с индексом i (п/у последний)
s.remove(x)
s.reverse()
s.sort()
sorted(s)

### Кортежи (): неизменяемые списки
- упорядоченная коллекция, как и список, но неизменяемая.
- при создании кортежа из одного элемента необходима запятая. без нее python воспримет запись как обычное выражение в скобках, а не как коллекцию.
```
one_number = (1, )
```
- удобны, когда нужно временно объединить значения
#### Методы и операции
Доступны только те, которые не изменяют коллекцию.

### Преобразование между коллекциями
list()
tuple()
str() - не объединяет элементы в одну строку, а возвращает строковое представление коллекции.
.join(...) - если надо собрать строку обратно из символов

# Множества, словари. Неупорядоченные коллекции
## Множества {}
- это тип коллекции, в которой автоматически удаляются повторяющиеся значения, а порядок не сохраняется.
- Отсутсвуют индексы.
- При выводе/запуске порядок элементов может отличаться

set() используется для
- создания пустого множества
- преобразования другой коллекции во множество

### Операции
- Объединение 
| или union()
- Пересечение
& или intersection()
- Разница
- или differenct()
- Symmetric difference
^ или symmetric_differenct()

- Множества можно сравнивать: ==, <, <=, >, >=

### Методы
Множества - изменяемый типа днных. Следующие методы изменяют множество.

set.add(e)
set.remove(e)       Выдает ошибку KeyError, если элемента нет
set.discard(e)      Не выдает ошибку
set.pop()           Удаляет произвольный элемент
set.clear()

## Словари {key:value}
- коллекция, в которой каждому значению сопоставляется ключ, что позволяет быстро получать доступ к нужной информации по понятному и уникальному идентификатору.
- коллекция пар ключ:значение.
- этот подход работает, но он не самый удобный - особенно при большом обёме данных.

- ключи могут быть неизменяемые типа данных: строки, числа, кортежи
- значения могут быть любого типа

### Добавление и изменение
dict[key] = value

При записи значения по уже существующему ключу, старое значение стирается, и ключ создаётся заново с новым значением.

Если попытаться получить значение по несуществующему ключу, программа завершится с ошибкой KeyError. Чтобы избежать ошибки, стоит вначале проверить, существует ли ключ:
```
countries_and_capitals = {"Россия": "Москва",
                          "США": "Вашингтон",
                          "Франция": "Париж"}
if "Сербия" in countries_and_capitals:
    print(countries_and_capitals["Сербия"])
else:
    print("Страна пока не добавлена в словарь")
```

### Перебор словаря в цикле
Пройтись по всем ключам словаря можно с помощью цикла for. При этом на каждой итерации переменная цикла принимает ключ, а значение можно получить по этому ключу.
```
countries_and_capitals = {"Россия": "Москва",
"США": "Вашингтон",
"Франция": "Париж"}
for country in countries_and_capitals:
    print(f"У страны {country} столица — {countries_and_capitals[country]}.")
```
### Методы словаря
len(d)
del d[key]                  Удлаяет ключ из словаря, если его нет - KeyError
dict.clear()
dict.get(key, default)      Возвращает значение по ключу. Если ключа нет, то - default
dict.items()
dict.keys()
d.pop(key, default)         Вовращает значение по ключу и удаляет. Если ключа нет - default.
dict.values()


# Списочные выражения. Модель памяти для типов языка Python
Списочное выражение
```
numbers = [int(input()) for i in range(5)]
```

Генератор
```
numbers = (int(input()) for i in range(5))
# print(numbers) не выведет числа, а покажето объект генератор.
# Чтобы получить значения, нужно проитерироваться по генератору.
```


Отличия:
- Список создает все элементы сразу и хранит их в памяти
- Генератор формирует значения по одному "запросу". Это экономит ресурсы и полезно при работе с большими объёмами данных.
- Генератор возвращает генератор-объект, который выдает значения по одному - не загружая в память весь список сразу.
- Генератор может быть быстрее, особенно при работе с большим объёмом данных
- 

## Создание n-мерного списка
```
zeros = [[0] * 5] * 5
```
Ошибка! Вместо копирования создается пять ссылок на один и тот же внутренний список.

Правильный способ:
```
zeros = [[0] * 5 for i in range(5)]
```

## Как Python хранит переменные в памяти
- Когда создается коллекция, Python хранит в ней не само значение, а лишь ссылку на область памяти, где значение размещено.
- Переменные - это ссылки. Если присваивается значение одной переменной другой, обе переменные будут указывать на один и тот же объект.

### Изменяемые и неизменяемые типа
- Изменяемые: list, set, dict
- Неизменяемые: int, float, str, tuple, frozenset

При изменении неизменяемых объектов создается новый объект с новым идентификатором.
У изменяемых объектов - можно изменить значение, не меняя идентификатор.

Но если используется операция присваивания, даже изменяемый объект будет заменён на новый.

Чтобы при присваивании создался отдельный объект, а не ссылка, можно использовать срез [:]. Но если список вложенный, срез копирует только внешний список.
Чтобы скопировать всё содержимое, можно либо использовать списочное выражение с for, либо функцию deepcopy из модуля copy.





















# Прочее
## Блокчейн
Блокчейн (blockchain) - способ хранения данных, защищенный от подделки, используемый, в частности, криптовалютой биткоин.
Блокчейн действительно представляет собой последовательность блоков. Каждый блок представляет собой некоторую полезнаю информацию, снабженную случайным числом и некоторыми служебными данными, в том числе хэшем - числом, которое по опредлённой формуле зависит от остальной части блока и хэша предыдущего блока. Хэш должен быть меньше определенного числа. При этом формула, по которой вычисляется хэш, устроена так, что невозможно получить достаточно маленький хэш иначе, чем перебирая различные значения случайного числа.

## Полезные команды

print(", ".join(letters))

getsizeof() - показывает сколько байт занимает объект

from timeit import timeit - засекает время

id() - возвращает идентификатор объекта

is - оператор, который проверяет равенство идентификаторов
